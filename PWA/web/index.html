<!DOCTYPE html>
<html style="width:100%;height:100%;">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Service Worker</title>

  <!-- 指定 manifest 配置文件 -->
  <link rel="manifest" href="/manifest.json">

</head>

<body style="width:100%;height:100%;">
  <main style="display:flex;height:100%;">

    <section style="flex:1;height:100%;border-right:2px solid #000;">
      <header style="text-align:center;border-bottom:1px solid #aaa;">测试 SyncManager</header>
      <p style="border-bottom:1px solid #aaa;">测试方法：先断网，点击按钮，观察启动服务器的控制台打印，恢复网络，会看到控制台打印路径(即接收到请求)。</p>
      <p style="border-bottom:1px solid #aaa;">备注： 到2019.12为止,SyncManager只有<strong>Chrome</strong>支持。</p>
      <button onclick="testSync()">TEST</button>
    </section>

    <section style="flex:1;height:100%;border-right:2px solid #000;">
      <header style="text-align:center;border-bottom:1px solid #aaa;">测试 Notification</header
        style="text-align:center;">
      <p style="border-bottom:1px solid #aaa;">测试方法：点击按钮后会弹出通知框。</p style="border-bottom:1px solid #aaa;">
      <button onclick="testNotification()">TEST</button>
    </section>

    <section style="flex:1;height:100%;border-right:2px solid #000;">
      <header style="text-align:center;border-bottom:1px solid #aaa;">测试 postMssage 和 MessageChannel</header
        style="text-align:center;">
      <p style="border-bottom:1px solid #aaa;">测试方法：打开控制台，点击按钮，控制台会显示给 serviceWorker 发送的内容，3 秒后，serviceWorker
        会自动发送数据给页面，页面弹出 alert 框显示。</p style="border-bottom:1px solid #aaa;">
      <p>
        <input type="text" id="my_input">
        <button onclick="testPostMsg()">TEST</button>
      </p>
    </section>

    <section style="flex:1;height:100%;">
      <header style="text-align:center;border-bottom:1px solid #aaa;">测试 Push</header style="text-align:center;">
      <p style="border-bottom:1px solid #aaa;">测试方法：点击按钮后，留意控制台，若打印"成功订阅"，则稍后在屏幕右下角会弹出通知框。</p>
      <p style="border-bottom:1px solid #aaa;">备注： 国内只有<strong>桌面版的FireFox</strong>能用。</p>
      <button onclick="subscribeUserToNotification()">
        TEST</button>
    </section>

  </main>
</body>

<!-- 注册 service worker -->
<script>
  // 特性检测
  if ('serviceWorker' in navigator) {
    // 注册
    navigator.serviceWorker.register('/sw.js', {
      scope: './'
    }).then(registration => {
      // ...
    }).catch(err => {
      // ...
    })
  } else {
    alert('浏览器不支持 service worker');
  }
</script>

<script>
  // 发起"同步"请求
  function testSync(e) {
    // 特性检测  (到2019.12为止,SyncManager只有谷歌支持)
    if (!'serviceWorker' in navigator || !'SyncManager' in window) {
      return alert('当前浏览器不支持 SyncManager ！')
    }
    // 先获取控制页面的 serviceWorker
    navigator.serviceWorker.ready.then(registration => {
      return registration.sync.register('mySyncTagName')
    }).then(_ => {
      // ...
    }).catch(_ => {
      // ...
    })
  }
</script>

<script>
  let msgChan

  function testPostMsg() {
    // 特性检测
    if (!"MessageChannel" in window) {
      return alert('浏览器不支持 MessageChannel ！');
    }

    // 获取 input 数据
    let inputValue = document.getElementById('my_input').value

    // 已创建 MessageChannel 则直接发送数据
    if (msgChan) {
      return msgChan.port1.postMessage(inputValue)
    }

    /**
     * 使用 MessageChannel (页面端)
     * 1. 先 new MessageChannel() 创建对象
     * 2. 监听 MessageChannel对象 的 port1 端口1
     * 3. 把 MessageChannel对象 的 port2 端口2 作为 .postMessage() 的第二个参数传入
     * 4. 剩下就是 serviceWorker 那边的事了...
     */
    msgChan = new MessageChannel(); // 此对象只有两个属性：port1和port2。
    // 注意，这里只能通过 onmessage 指定监听器，不能使用 addEventListener
    msgChan.port1.onmessage = e => {
      alert('来自 service worker 的消息：' + e.data)
    }

    // 特性检测
    if (!'serviceWorker' in navigator) {
      return alert('浏览器不支持 serviceWorker ！')
    }
    // navigator.serviceWorker.controller 可以获取控制页面的 serviceWorker ，
    // 但首次加载后，serviceWorker 并不能马上控制页面，此时的 controller 值为 undefined
    // postMessage 的第一个参数可以是任意类型
    // 第二个参数附带端口 (当忽略第二个参数时，就是普通的单次传递消息)
    navigator.serviceWorker.controller.postMessage('保持通话,得闲饮茶', [msgChan.port2])

    // 利用端口发送数据
    msgChan.port1.postMessage(inputValue)
  }
</script>

<script>
  // 使用 Notification API 推送消息
  function testNotification() {
    new Promise((resolve, reject) => {
      // 通过 Notification.permission 可以查询权限状态
      if (Notification.permission !== 'granted') {
        Notification.requestPermission().then(permission => {
          // permission 的值有三种可能： default(没同意也没拒绝)、 granted(同意)、 denied(拒绝)。
          permission === 'granted' ? resolve() : reject()
        })
      } else {
        resolve()
      }
    }).then(_ => {
      navigator.serviceWorker.controller.postMessage('showNotification')
    }).catch(_ => {
      console.error(_)
    })
  }
</script>

<script>
  // 此函数作用：将 VAPID 公钥转换成 pushManager 所需的 Uint8Array 类型 (可以忽略其内部实现,除非你对密码学感兴趣)
  function urlBase64ToUint8Array(base64String) {
    var padding = "=".repeat((4 - base64String.length % 4) % 4);
    var base64 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
    var rawData = window.atob(base64);
    var outputArray = new Uint8Array(rawData.length);
    for (var i = 0; i < rawData.length; i++) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray
  }

  // 封装"创建订阅"
  function subscribeUserToNotification() {
    navigator.serviceWorker.ready.then(registration => {
      // 获取 PushManager 接口
      return registration.pushManager.subscribe({
        // 必须设为 true ，否则消息服务器会报错，这是因为涉及用户隐私问题。
        userVisibleOnly: true,
        // 将 VAPID 转换成 Uint8Array 类型
        applicationServerKey: urlBase64ToUint8Array(
          'BK04agj20CeTyhv9EkDv9d36n8tZ3a6FzeiS7MBmzxZRYSaDUgsYAYagvoTKMmJTmepBH_50r71pQQeqhmu8bEo')
      })
    }).then(subscribe => {
      // 把"订阅详情"发送到服务器保存
      return fetch('/addsubscription', {
        method: 'post',
        headers: new Headers({
          "Content-Type": "application/json"
        }),
        body: JSON.stringify(subscribe)
      })
    }).then(_ => {
      console.log('成功订阅')
    }).catch(_ => {
      console.error(_)
    })
  }
</script>


</html>