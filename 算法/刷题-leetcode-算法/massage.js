/**
  面试题 17.16. 按摩师

  一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
  注意：本题相对原题稍作改动

  示例 1：
  输入： [1,2,3,1]
  输出： 4
  解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。

  示例 2：
  输入： [2,7,9,3,1]
  输出： 12
  解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。

  示例 3：
  输入： [2,1,4,5,3,1,1,3]
  输出： 12
  解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var massage = function (nums, index = 0) {
  // 思路：动态规划
  // 对于每个选项，只有两种可能： 选 或 不选
  // 选：开始索引就是当前索引加 2
  // 不选：当前索引加 1 继续计算
  // 出口：索引值超出数组长度

  if (index >= nums.length) return 0
  let selected = nums[index] + massage(nums, index + 2),
    unselected = massage(nums, index + 1)
  return Math.max(selected, unselected)
};
// 上面方法超时



massage = function (nums) {
  const dp = [];
  // 等同于将数组前面多增两个 0 ，方便计算
  dp[0] = 0;
  dp[1] = 0;
  for (let i = 2; i < nums.length + 2; i++) {
    // 每次移动一位
    // 对比选择了当前这位与之前的最大值(即不选当前位)的最大值
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }
  return dp[nums.length + 1];
};



// console.log(massage([1, 2, 3, 1, 5, 6, 8, 9, 5, 6, 7]))
console.log(massage([183, 219, 57, 193, 94, 233, 202, 154, 65, 240, 97, 234, 100, 249, 186, 66, 90, 238, 168, 128, 177, 235, 50, 81, 185, 165, 217, 207, 88, 80, 112, 78, 135, 62, 228, 247, 211])) // 3365
// console.log(massage([114, 117, 207, 117, 235, 82, 90, 67, 143, 146, 53, 108, 200, 91, 80, 223, 58, 170, 110, 236, 81, 90, 222, 160, 165, 195, 187, 199, 114, 235, 197, 187, 69, 129, 64, 214, 228, 78, 188, 67, 205, 94, 205, 169, 241, 202, 144, 240]))